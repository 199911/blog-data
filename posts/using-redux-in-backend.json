{"title":"Using Redux in server-side","permalink":"/using-redux-in-backend","post":{"title":"Using Redux in server-side","date":"2017-01-29T00:00:00.000Z","categories":"Diary","__content":"<p>Redux store the state of whole app into a single object. Which make the system's state transition predictable and manageable. I try to apply Redux as an event system in backend. But unfortunately, it does not work.</p>\n<!-- more -->\n<h1 id=\"howiusereduxinserverside\">How I use Redux in server side</h1>\n<p>My idea is, every time user send a request to server, we queue it up (add the request to store). After that the server will take action base on the state. The server subscribes the change of store and decide which action to take.</p>\n<pre><code>(Server router get request) -&gt; (dispatch action) -&gt; (reducer put the request in the state)\n                                    ^                                  |\n                                    |                                  v\n                         (Server process requests) -&gt;  (Server subscribe the change)\n</code></pre>\n<p>The diagram looks good, the logic flow is very clear. But there are lots of problems during implementation</p>\n<h2 id=\"serveractioncareactionsnotstates\">Server action care actions, not states</h2>\n<p>In server side, the most logic only care 'changes', not 'state'. Take web server as an example.</p>\n<p>At first, there are no request, so the store looks like <code>{queue: []}</code>.\nWhen there is a 'index.html' request, I will store the request in the queue and start processing it. The store looks like <code>{queue: ['index.html']}</code>.\nIf we get 'index.html' request from another user, we can found there is a same request. From the app state, we don't know we are computing the result or not, we don't know should we process the request.\nTherefore, we have to store the state of request. like</p>\n<pre><code>{\n  queue: [\n    {page:'index.html', state:'processing'}\n  ]\n}\n</code></pre>\n<p>And we need to have lots of action and reducer to transit the state of request.</p>\n<p>These kind of state does not means much in server side. If the request is processing, we only need to wait, we don't have logic hooked on the <code>processing</code> state. But in client side, we may have a lot UI to update when the request is processing, the state will be very useful to prevent user from confusion.</p>\n<p>Short conclusion: Redux keeps all app state in a clear way. It is very important in client side, because we need to guarantee the data present to user is consistent and up-to-date. But in server side logic, we only care \"what is do we need to process\", instead of \"what are we processing now\". Using \"state first\" approach in server side introduce lots of boilerplate code.</p>\n<h2 id=\"hookandanchorpatternimplementationiscomplexinredux\">Hook and Anchor pattern implementation is complex in Redux</h2>\n<p>Hook and anchor pattern is useful in server side, like the <code>the_content</code> hook in Wordpress, which will be call before the post content sent to client, allow programmer inject customization content component easily. But in Redux, the implementation is not very straight forward.</p>\n<pre><code>const reducer = (action, state) =&gt; {\n  switch(action.type) {\n    'UPDATE_FETCH_POST_STATE':\n      return action.state;\n    ...\n  }\n}\n\ndispatch({type:'UPDATE_FETCH_POST_STATE', state:'preparing'});\ndispatch({type:'UPDATE_FETCH_POST_STATE', state:'running'});\nfetchPost()\n  .then(() =&gt; {\n    dispatch({type:'UPDATE_FETCH_POST_STATE', state:'done'});\n  })\n</code></pre>\n<p>To implement the filter, we need to have 2 action to change the state to preparing and running. Because the 'event subscriber' in Redux can only see the state, we need to create a short 'section' to notify the subscriber. The implementation is more complex than the pub-sub.</p>\n<h2 id=\"difficulttohandleasynchookhandlerinredux\">Difficult to handle async hook handler in Redux</h2>\n<p>As dispatch does not return the anything about the subscriber, don't know what subscriber did. If the subscriber is async, we cannot know it is finished or not. In some scenarios, it is a big problem.</p>\n<p>For example, I want to insert the author data in post content, we need to run <code>getAuthorAsync()</code> before sent the content. We cannot guarantee <code>getAuthorAsync()</code> finished before <code>fetchPost()</code> using <code>dispatch()</code>.</p>\n<p>In another implementation, we can implement this in a very simple way.</p>\n<pre><code>// Return all return value of hook handlers\nconst handlers = willFetchPostHooks();\nPromise.all(handlers)\n  .then(() =&gt; {\n    return fetchPost();\n  })\n  .then((post) =&gt; {\n    ...\n    return Promise.all(didFetchPostHooks());\n  })\n</code></pre>\n<p>Asynchronous hooks are very common in server side, as most task in backend take a longer process time. But in client side, it is not a big problem, as most of the action (UI update) are short and synchronous.</p>\n<h1 id=\"betterwayinserverside\">Better way in server side</h1>\n<p>Redux separate the state of each component, and store them in a single store. But we don't need to do it in server side, because server side logic don't have lots of share states. Using traditional OOP, each object take care of their own states may be good enough.</p>","filePath":"/Users/sunday/workspace/coding-sunday/source/_posts/diary/using-redux-in-backend.md","slug":"using-redux-in-backend"}}