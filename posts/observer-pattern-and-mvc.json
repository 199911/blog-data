{"title":"Observer pattern and MVC","language":"zh-tw","date":"2016-06-24T00:00:00.000Z","categories":"Diary","__content":"<p>@thwonghenry refactor the javascript of an inhouse plugin and I am the one who review his code. He apply the observer pattern and we have some discussion on it.</p>\n<!-- more -->\n<h2 id=\"observerpattern\">Observer pattern</h2>\n<p>There are two roles in observer pattern, subject and observer. Subject is an object implemented <code>on()</code> and <code>notify()</code>. Observers are modules, objects or functions depend on subject.</p>\n<p>The pattern works in this way: observers' logic is not embedded in subject directly, they register a \"handler\" to subject's \"events\" using <code>on()</code>. When the subject is called, subject fire an event using <code>notify()</code> and call the \"handlers\" which registered that specific event.</p>\n<h2 id=\"whenandwhyweuseobserverpattern\">When and why we use observer pattern?</h2>\n<p>From the definition, we know there 3 components in observer pattern: subject, events and observers. A specific action of subject trigger specific events and specific observers are notified by specific event. In other words, specific subject action trigger specific observer action indirectly. Subject is depending on observers. Observer pattern is decoupling the subject and observers by converting the dependency to an \"event\".</p>\n<p>As long as two objects or modules have a fixed dependency or relationship, we can apply observer pattern. But why we need it?</p>\n<h2 id=\"reusesimilardependency\">Reuse similar dependency</h2>\n<p>It is common to have dependency among modules, we can convert an abstract \"dependency\" to a concrete \"event\". Therefore we can organize the dependency in a tidy way. Also, when there are new dependency, we can register the function to the \"event\" without changing logic of any modules.</p>\n<p>For example, when there is a fire in building, we need to call fire station, turn on sprinkler and resident need to escape. We can consider <code>resident</code>, <code>sprinkler</code> and <code>fireStation</code> objects depend on <code>building</code> object. We can implement the dependency like this:</p>\n<pre><code>building.fire = function(){\n    resident.escape();\n    sprinkler.water();\n    fireStation.call();\n}\n</code></pre>\n<p>If we need to do something more now, such as journalist needs to report the fire in news, we have to update <code>building.fire</code>.</p>\n<pre><code>building.fire = function(){\n    building.notify(\"fire\");\n    resident.escape();\n    sprinkler.water();\n    fireStation.call();\n    journalist.report();\n}\n</code></pre>\n<p>Everytime we change a piece of deployed code, we need to do a lot of testing to make sure no new or regression bugs is introduced. This can be avoided by observer pattern.</p>\n<pre><code>building.fire = function(){\n    this.notify(\"fire\");\n}\n\nbuilding.on(\"fire\", resident.escape);\nbuilding.on(\"fire\", sprinkler.water);\nbuilding.on(\"fire\", fireStation.call);\n</code></pre>\n<p>To let journalist to report the new, we only need to append <code>building.on(\"fire\", journalist.report);</code> to some where, without changing any implemented functions.</p>\n<h2 id=\"howobserverpatternplaysitspartinmvc\">How observer pattern plays its part in MVC?</h2>\n<p>In user interface, there are two main components, data models and front end views. They have a fixed dependency. For example, when user click a button, some data need to be updated. After a model is updated, some tables need to be updated. The code will look like this:</p>\n<pre><code>button.click = function(){\n    data.update();\n    ...\n}\ndata.update = function(){\n    table.update();\n    ...\n}\ntable.update = function(){\n    ...\n}\n</code></pre>\n<p>We have a button.click -&gt; data.update -&gt; tables.update chains. When we have more UI components or more complex data logic, the chain will be getting longer and the code become unmaintainable.</p>\n<p>If we use observer pattern, the code will look like this</p>\n<pre><code>button.click = function(){\n    this.notify(\"click\");\n}\ndata.update = function(){\n    ...\n    this.notify(\"update\");\n}\ntable.update = function(){\n    ...\n}\n</code></pre>\n<p>and we have to register handlers to events.</p>\n<pre><code>button.on('click', data.update);\ndata.on('update', table.update);\n</code></pre>\n<p>There are no nested function calls anymore. Observer \"flatten\" the code for us. Observer pattern is converting \"model update\" and \"view update\" dependencies into events and save programmers from trivial handling of components update chains.</p>\n<p>We have a MVC structure now. We can put <code>data.update()</code> in models, <code>buton.click()</code> and <code>table.update()</code> in views. The controller will be the event registration logic like <code>button.on('click', data.update);</code> and <code>data.on('update', table.update);</code>.</p>\n<h2 id=\"mvcisanexampleofobserverpattern\">MVC is an example of observer pattern</h2>\n<p>To sum up, MVC is a special scenario of observer pattern, which hide the detail on update chains of models and views. By putting the dependency definition in controller, we can decouple model logic and view logic.</p>\n<h2 id=\"furtherimprovement\">Further improvement</h2>\n<p>After we identitfy the problem in MVC, we will get redux. But I am not familiar with it, I better not discuss it here.</p>\n<h2 id=\"reference\">Reference</h2>\n<p>http://stackoverflow.com/questions/15594905/difference-between-observer-pub-sub-and-data-binding\nhttps://en.wikipedia.org/wiki/Observer_pattern</p>","filePath":"/Users/sunday/workspace/coding-sunday/source/_posts/diary/observer-pattern-and-mvc.md","slug":"observer-pattern-and-mvc"}