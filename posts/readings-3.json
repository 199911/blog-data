{"title":"文集三","permalink":"/readings-3","post":{"title":"文集三","language":"zh-tw","date":"2016-07-02T00:00:00.000Z","categories":"Insight","__content":"<h2 id=\"viewcontrollershttpobjccnioissue11\"><a href=\"http://objccn.io/issue-1-1/\">更轻量的 View Controllers</a></h2>\n<p>文中帶出 MVCS 嘅 concept 去改MVC，S可以係 Store 或 Service 嘅簡寫，都係指同一樣野。其實就係將 Model 嘅 database 或 network logic 放去 Store/Service object，令個Controller 可以精簡一D。</p>\n<h2 id=\"mvvmhttpobjccnioissue131\"><a href=\"http://objccn.io/issue-13-1/\">MVVM 介绍</a></h2>\n<p>VM stand for View Model. The idea is to improve MVC by adding a layer (View Model) between Controller and Model.\nView Model handles all presnetation logic, such as format data in Model for View. In MVC, we put the data formating code in Controller. MVVM make the controller slimmer.</p>\n<p>We should put all code which cannot be reused in Controller. I thought data format code usually is not reusabile, it makes sense to put the logic in Controller. When the system grow and become more complex, we can apply MVVM to break down the controller is small pieces. So the code base will be cleaner.</p>\n<p>Pros of MVVM:</p>\n<ul>\n<li>easy to migrate from MVC by adding view models<ul>\n<li>we can migrate progressively</li></ul></li>\n<li>view model is testable<ul>\n<li>in most cases, controller is not worth to write automated test</li></ul></li>\n<li>easier to bind logic, as controller is smaller</li>\n</ul>\n<p>I have no experience on MVVM. I need to find some example to support my thought</p>\n<!-- more -->\n<h2 id=\"httpobjccnioissue134\"><a href=\"http://objccn.io/issue-13-4/\">子类</a></h2>\n<p>If two class have few common method, we should not use sub-class pattern. If two class have the same interface, but different implementation, there are better design pattern than sub-class. In weak typing language, we can use duck typing directly.</p>\n<p>Objective C is a strong typing language. The article provide 4 design patterns:</p>\n<h3 id=\"delegate\">Delegate</h3>\n<p>A delegate object is injected, which is a specific implementation of the method. What we need to do is only keep the same function interface.</p>\n<h3 id=\"configuration\">Configuration</h3>\n<p>We provide an interface to let user configurate the implementation. It is perfect for the language with first class function. We only need to pass the implementation, instead of implementation lots of sub class.</p>\n<pre><code>// Suppose we have a class \"MessageSender\" to send a message to different channel\nvar sender = new MessageSender();\n// We don't need to create a set of subclass \"SlackSender\", \"MessagerSender\" and \"WhatsAppSender\"\n// We only need to pass the implementation to the object like this:\nsender.config(function sendToSlack(){\n    ...\n})\nsender.config(function sendToMessager(){\n    ...\n})\nsender.config(function sendToWhatsApp(){\n    ...\n})\n</code></pre>\n<h3 id=\"categoriesandcombinations\">Categories and Combinations</h3>\n<p>I think these two patterns are specific for Objective C. In most of the modern language, we have duck typing. We can replace these pattern with duck typing.</p>\n<h2 id=\"objectivechttpblogxcodevcompostsobjectivecnaming\"><a href=\"http://blog.xcodev.com/posts/objective-c-naming/\">Objective-C之优雅的命名</a></h2>\n<p>It give some guideline on naming functions and variables.</p>\n<ul>\n<li>No short form unless it is common term<ul>\n<li>URL, HTTP is acceptable</li>\n<li>Need to have a consensus on \"Common Terms\" with in a team</li></ul></li>\n<li>Use <code>Will</code>, <code>Did</code> and <code>Should</code> prefix for naming function with specific purpose<ul>\n<li><code>Will</code> is the hook run before some action, such as <code>WillSendMessage = function(){...}</code>.</li>\n<li><code>Did</code> is the hook run after some action, such as <code>DidSendMessage = function(){...}</code>.</li>\n<li><code>Should</code> determine whether some action should be perform or not. It always return a boolean. Such as <code>ShouldSendMessage = function(context){...}</code></li></ul></li>\n<li>Put data description before data type<ul>\n<li><code>titleLabel</code> is better than <code>labelTitle</code></li></ul></li>\n</ul>\n<p>I don't argee with the <code>Get</code> function prefix part outside the context of Objective C.</p>\n<pre><code>Class foo {\n    function get_value($query, &amp;$value){\n        ...\n        $value = \"some value\";\n        return $is_success;\n    }\n    function value(){\n        ...\n        return \"some value\";\n    }\n}\n</code></pre>\n<p><code>get_value()</code> put the return value into input parameter by reference. <code>value()</code> return the value directly.\nThere are three drawbacks:</p>\n<ul>\n<li><code>get_value</code> have 2 entry point<ul>\n<li>Try to avoid function's \"side effect\" by avoid using pass by reference</li>\n<li>Function should return value using <code>return</code>, it make the code easier to understand</li>\n<li>If we want to detect error, we should use <code>throw</code> instead of <code>return</code> some falsy value.</li></ul></li>\n<li>It is confusing to determine <code>value</code> is a function or object field<ul>\n<li>This may be ok for Objective C, as function calling and data accessing have different syntax\nI prefer to use <code>get_value()</code> for object function and <code>value</code> for object data.</li></ul></li>\n</ul>\n<h2 id=\"iosapphttpstudentdenggithubioblog20140829iosarchitecture\"><a href=\"http://studentdeng.github.io/blog/2014/08/29/ios-architecture/\">iOS APP 架构漫谈</a></h2>\n<p>\"How to manage the information flow\" is the problem front-end architecture pattern want to solve. I can see the shawdon of MVC and redux from the examples.</p>","filePath":"/Users/sunday/workspace/coding-sunday/source/_posts/insight/readings-3.md","slug":"readings-3"}}