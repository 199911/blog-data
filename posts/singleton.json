{"title":"Review of \"Avoiding Singleton Abuse\"","permalink":"/singleton","post":{"title":"Review of \"Avoiding Singleton Abuse\"","date":"2016-07-04T00:00:00.000Z","categories":"Review","__content":"<p>The singleton mentioned here is Singleton Design Pattern</p>\n<ul>\n<li>Private constructor</li>\n<li>Global referal to the instace</li>\n</ul>\n<h3 id=\"singletonisglobalvariable\">Singleton is global variable</h3>\n<p>The singleton instance can be access in every where. Actually, singleton instance is a group od global variables and methods. If we use singleton instance incorrectly, it will bring the problems from global vairables.</p>\n<!-- more -->\n<h3 id=\"whyglobalvariableisevil\">Why global variable is evil?</h3>\n<p>The root of the problem is, the dependencies of modules on global variable is not clear. It makes the module difficult to understand and test.</p>\n<p>For example,</p>\n<pre><code>function foo(){\n    global $bar;\n    // or\n    $bar = Singleton::get_instance()-&gt;bar;\n    return ($bar &gt; 10);\n}\n</code></pre>\n<p>If we run <code>foo()</code>, it can return <code>true</code> or <code>false</code>. As <code>foo()</code> depends on $bar implicitly, we have no idea why the behaviour changed, until we read the source code. This means <code>foo()</code> fail to abstract the detail of implementation.</p>\n<h3 id=\"howsingletonsolvetheimplicitlydependency\">How Singleton solve the implicitly dependency?</h3>\n<p>Singleton instance is similar to global variable, but it can solve the implicitly dependency casued by gloabl variable. What we need is \"Dependency Injection\". It means we do not depend on the method directly in the implementation, but we pass the dependency using parameters.</p>\n<p>Let's rewrite <code>foo()</code></p>\n<pre><code>function foo($singleton){\n    $bar = $singleton-&gt;bar;\n    return ($bar &gt; 10);\n}\n// We call foo() like this\nfoo(Singleton::get_instance());\n</code></pre>\n<p>Everytime, we call <code>foo()</code>, we know which module it depends on. We can test the function easily by changing the dependency to a mock instance.</p>\n<p>In another aspect, read-only global variable do no harm. If the Singleton's fields are constant, and methods have no side effect, feel free to use Singleton. But in these case, static class or namespace may be a better choice.</p>\n<p>To sum up, advantage of Singleton pattern faciliate dependency injection.</p>\n<h3 id=\"lifespanofobjectisnotastrongreasontousesingleton\">Lifespan of object is not a strong reason to use singleton</h3>\n<p>If only one object is needed in the whole software does not mean we must use singleton. We can just create an object and store it in somewhere but not in the global scope. We shoud handle the lifespan of the object careful. We cannot escape the responsiblity on lifespan handling by abusing Singleton pattern.</p>\n<p>We need to understand what problem does the design pattern want to solve before applying them. \"We only need one object\" is not a sounded reason to apply Singleton. Software requirement always change, we only need one object now, but we may need more in the future. Applying design pattern in a wrong way make the system unneccesorily complex, increase the difficulty on developmention and maintainance.</p>\n<h2 id=\"reference\">Reference</h2>\n<p><a href=\"https://www.objc.io/issues/13-architecture/singletons/\">Avoiding Singleton Abuse</a></p>\n<p>PS: In the article they use a built in function <code>dispatch_once()</code>, it makes the refactoring from singleton to object difficult. But in other language, singleton to objects may be a smooth transition</p>","filePath":"/Users/sunday/workspace/coding-sunday/source/_posts/review/singleton.md","slug":"singleton"}}