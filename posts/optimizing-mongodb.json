{"title":"Review of \"Optimizing MongoDB: Lessons Learned at Localytics\"","date":"2016-06-09T00:00:00.000Z","categories":"Review","__content":"<p>This article is talking about how to optimizing MongoDB. I don't understand what it says becuase I am not familiar with MongoDB. It shows that optimizing is inevitably involve the implementation of an abstraction layer. It is hard to learn, but it is rewarding.</p>\n<!-- more -->\n<h2 id=\"documentdesign\">Document Design</h2>\n<p>In term of SQL, it is table design. The main idea is to reduce the document size. It suggest to shorten the field's name, use binary to store id instead of strings and remove extra index. This will make the document difficult to understand. We need better doucmentation and introduce a layer for translating the data.</p>\n<h2 id=\"indextricks\">Index tricks</h2>\n<p>The idea is to reduce index size by partition the index. It is useful when the field doesn't have many possible values. A similar technique can be applied in MySQL. It is a trade off between the space required for the index and the cardinality of the index.</p>\n<h2 id=\"fragmentation\">Fragmentation</h2>\n<p>It is similar to fragmentation on file system. When we delete a document, there will be a 'hole' in the disk. To reduce the 'hole', we may need to break down the new document into small pieces. A read action will cost more disk operation. MongoDB provide a <code>repair</code> command to fix this problem, but it is very slow.</p>\n<h2 id=\"chunkmigration\">Chunk migration</h2>\n<p>Chunks are a logical construct in MongoDB, the documentation are not neccessary to be stored in the same place. The solution is to migrate chunk to shard.</p>\n<p>Using a better shard keys can avoid bad migrations. If we know our key distribution, we can pre-create chucks and assign shard keys. One suggestion is to include time in the shard key, but beware of write hotspot</p>\n<h2 id=\"hardwareoptimization\">Hardware optimization</h2>\n<p>The performance is very bad if the data is not in RAM</p>\n<ul>\n<li>Do a read operation before update to warm up the doc in RAM</li>\n<li>Read can run in parallel, but update hold a lock</li>\n</ul>\n<p>Use a shard per core instead of shard per server</p>\n<ul>\n<li>Overcome write locks when writes per second matter</li>\n<li>As MongoDB use a big write lock\nThe article is written on 2011, I am not sure this technique is still valid. As mongoDB seems have lots of change on write lock.</li>\n</ul>\n<h2 id=\"conclusion\">Conclusion</h2>\n<p>When we need to do optimization</p>\n<ol>\n<li>Having basic understanding on the implementation of abstraction layers</li>\n<li>Search related resource on optimization</li>\n<li>If we cannot understand why the optimization works, it means our understanding on the abstraction layer is not deep enough. Better to do more research on the implementation of abstraction layers</li>\n<li>After getting enough context and knowledge of the abstraction layers, we can try to apply optimization skills</li>\n<li>Review the performance afte optimization, go back to step 3 if the result is not good enough.</li>\n</ol>\n<h2 id=\"reference\">Reference</h2>\n<p><a href=\"http://eng.localytics.com/optimizing-mongodb-lessons-learned-at-localytics/\">Optimizing MongoDB: Lessons Learned at Localytics</a></p>","filePath":"/Users/sunday/workspace/coding-sunday/source/_posts/review/optimizing-mongodb.md","slug":"optimizing-mongodb"}